version: '3'

services:

  
  mongodb:
    image: mongo
    ports:
    - "27017:27017"

  postgresdb:
    image: postgres
    ports:
    - "5555:5432"
    environment:
    - POSTGRES_USER=postgres
    - POSTGRES_PASSWORD=titanic99

  tweet_collector:
    build: tweet_collector/
    volumes:
    - ./tweet_collector/:/app
    depends_on:
     - mongodb
     - postgresdb

  etl_job:
    build: etl_job/
    volumes:
     - ./etl_job/:/app2
    depends_on:
     - mongodb
     - postgresdb

  slack_bot:
    build: slack_bot/
    volumes:
    - ./slack_bot/:/app3
    depends_on:
      - mongodb
      - postgresdb


#version: '3'
#services:
# first: Mongo DB
 # mongodb:
  #  image: mongo
   # ports:
    #- 27017:27017

# second: SQL DB
  #postgresdb:         
   # image: postgres    
    #ports:
    #- 5555:5432        

    #environment:   
    #- POSTGRES_USER=postgres    
    #- POSTGRES_PASSWORD=titanic99    
    #- POSTGRES_DB=twitter_database

# third: run Python tweet_collector
  #tweet_collector:
   # build: tweet_collector/
    #volumes:
   # - ./tweet_collector/:/app
    #depends_on:
    #- mongodb
    #- postgresdb


# 4th: run Python 
  #etlbot:              # name
   # build: etl/     # look for a Dockerfile here -> creates an image
    #volumes:               # this is how we get the python program + files in:
    #- ./etl/:/app   # makes the karaokebot/ folder available in the container as app/
    #depends_on:            # this means that the postgres container is started then the karaokebot
    #- mongodb
    #- postgresdb
